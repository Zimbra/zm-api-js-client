enum SortBy {
	none
	dateAsc
	dateDesc
	subjAsc
	subjDesc
	nameAsc
	nameDesc
	rcptAsc
	rcptDesc
	attachAsc
	attachDesc
	flagAsc
	flagDesc
	priorityAsc
	priorityDesc
	readAsc
	readDesc
	sizeAsc
	sizeDesc
}

enum FreeBusyStatus {
	F # Free
	B # Busy
	T # Tentative
	O # Out of Office
}

enum AccountType {
	imap
	pop3
}

enum ConnectionType {
	cleartext
	ssl
	tls
	tls_is_available
}

enum PrefCalendarInitialView {
	day
	list
	month
	week
	workWeek
	year
}
enum PrefMailSendReadReceipts {
	prompt
	always
	never
}

enum AlarmAction {
	DISPLAY
	AUDIO
	EMAIL
	PROCEDURE
	X_YAHOO_CALENDAR_ACTION_IM
	X_YAHOO_CALENDAR_ACTION_MOBILE
	NONE
}

enum AlarmRelatedTo {
	START
	END
}

enum Weekday {
	SU
	MO
	TU
	WE
	TH
	FR
	SA
}

enum CalendarItemRecurrenceFrequency {
	SEC
	MIN
	HOU
	DAI
	WEE
	MON
	YEA
}

enum InviteReplyVerb {
	ACCEPT
	DECLINE
	TENTATIVE
}

enum InviteReplyType {
	r #reply
	w #forward
}

enum AutoCompleteMatchType {
	gal
	contact
	rankingTable
}

enum ParticipationStatus {
	NE # needs-action
	AC # accept
	TE # tentative
	DE # declined
	DG # delegated
	CO # completed
	IN # in-process
	WA # waiting (only tasks)
	DF # deferred (only tasks)
}

enum InviteCompletionStatus {
	NEED # Not Started / Need Response
	TENT # Tentative
	CONF # Confirmed
	CANC # Cancelled
	COMP # Completed
	INPR # In Progress
	WAITING # Waiting on someone else
	DEFERRED # Deferred
}

enum ParticipationRole {
	REQ # required
	OPT # optional
	NON # informational purposes only
}

enum CalendarItemClass {
	PRI # Private
	PUB # Public
	CON # Confidential
}

enum AddressType {
	f # from
	t # to
	c # cc
	b # bcc
	r # reply-to
	s # sender
	n # read-receipt notification
	rf # resent-from
}

# https://github.com/Zimbra/zm-mailbox/blob/develop/store/docs/acl.md
enum GranteeType {
	usr # Zimbra User
	grp # Zimbra Group (distribution list)
	egp # an external AD group
	dom # Zimbra Domain
	all # All authenticated users
	pub # public access
	guest # Non-zimbra email address and password
	key # Non-Zimbra email address and access key
	cos # Grantee ID must match zimbraCOSId (Class of Service)
}

enum SearchType {
	conversation
	message
	contact
	appointment
	task
	wiki
	document
}

enum FolderView {
	search
	folder
	tag
	conversation
	message
	contact
	document
	appointment
	virtual
	remote
	wiki
	task
	chat
	note
	comment
}

enum GalSearchType {
	all
	account
	resource
	group
}

enum NeedIsMemberType {
	all
	directOnly
	none
}

enum ReadingPaneLocation {
	off
	right
	bottom
}

enum PrefMailSelectAfterDelete {
	next
	previous
	adaptive
}

enum ActionTypeName {
	ContactAction
	ConvAction
	DistributionList
	FolderAction
	ItemAction
	MsgAction
	TagAction
}

enum LicenseStatus {
	OK
	NOT_INSTALLED
	NOT_ACTIVATED
	IN_FUTURE
	EXPIRED
	INVALID
	LICENSE_GRACE_PERIOD
	ACTIVATION_GRACE_PERIOD
}

enum SetRecoveryAccountOp {
	sendCode
	validateCode
	resendCode
	reset
}

enum SetRecoveryAccountChannel {
	email
}

enum RecoverAccountOp {
	getRecoveryAccount
	sendRecoveryCode
}

enum PasswordRecoveryAddressStatus {
	verified
	pending
}

enum ZimletPresence {
	mandatory
	enabled
	disabled
}

type AuthResponse {
	authToken: [AuthToken]
	lifetime: Int
	session: Session
	skin: [Skin]
}

type AuthToken {
	_content: String
}

type Session {
	id: ID
	_content: String
}

type Skin {
	_content: String
}

type CalOrganizer {
	address: String
	name: String
	url: String
	sentBy: String
}

type Instance {
	start: Float
	dueDate: Float
	tzoDue: Int
	utcRecurrenceId: String
	isException: Boolean # ex
	alarm: Boolean
	allDay: Boolean
	changeDate: Float # md
	class: CalendarItemClass
	componentNum: Int # compNum
	date: Float # d
	duration: Float # dur
	excerpt: String # fr
	flags: String # f
	freeBusy: FreeBusyStatus # fb
	freeBusyActual: FreeBusyStatus # fba
	inviteId: ID #invId
	location: String # loc
	modifiedSequence: Int # ms
	name: String
	organizer: CalOrganizer # or
	participationStatus: ParticipationStatus
	revision: Int # rev
	status: InviteCompletionStatus
}

type InviteReplyResponse {
	inviteId: ID #invId
	calendarItemId: ID #calItemId
}

type ModifyAppointmentResponse {
	appointmentId: ID #appointmentId
	calendarItemId: ID #calItemId
	inviteId: ID #invId
	modifiedSequence: Int # ms
	revision: Int # rev
}

type ZimletPref {
	name: String
	presence: String
}

type ModifyZimletPrefsResponse {
	zimlet: [ZimletPref]
}

type EmailAddress {
	address: String
	name: String
	type: String
	displayName: String
}

type ShareNotification {
	truncated: Boolean,
	content: String
}

type MessageAttributes {
	isEncrypted: Boolean
	isSigned: Boolean
}

interface MailItem {
	id: ID
	size: Float # s
	date: Float # d
	folderId: ID # l
	subject: String # su
	emailAddresses: [EmailAddress]
	excerpt: String # fr
	conversationId: ID # cid
	flags: String # f
	tags: String # t
	tagNames: String # tn
	revision: Int # rev
	changeDate: Float # md
	modifiedSequence: Int # ms
	invitations: [InviteInfo] # inv
	sortField: String # sf, Sort field used for cursor-based pagination
	share: [ShareNotification] # shr
	replyType: String #rt
}

type MessageInfo implements MailItem {
	id: ID
	size: Float # s
	date: Float # d
	folderId: ID # l
	origId: ID #origid
	subject: String # su
	emailAddresses: [EmailAddress]
	excerpt: String # fr
	conversationId: ID # cid
	flags: String # f
	tags: String # t
	tagNames: String # tn
	revision: Int # rev
	changeDate: Float # md
	modifiedSequence: Int # ms
	invitations: [InviteInfo] # inv
	sortField: String # sf, Sort field used for cursor-based pagination
	mimeParts: [MimePart]
	to: [EmailAddress]
	from: [EmailAddress]
	cc: [EmailAddress]
	bcc: [EmailAddress]
	sender: [EmailAddress]
	html: String
	text: String
	attachments: [MimePart]
	inlineAttachments: [MimePart]
	share: [ShareNotification] # shr
	replyType: String #rt
	attributes: MessageAttributes
}

type Conversation implements MailItem {
	id: ID
	size: Float # s
	date: Float # d
	folderId: ID # l
	subject: String # su
	excerpt: String # fr
	emailAddresses: [EmailAddress]
	conversationId: ID # cid
	flags: String # f
	tags: String # t
	tagNames: String # tn
	revision: Int # rev
	changeDate: Float # md
	modifiedSequence: Int # ms
	invitations: [InviteInfo] # inv
	sortField: String # sf, Sort field used for cursor-based pagination
	messages: [MessageInfo]
	messagesMetaData: [MessageInfo]
	numMessages: Int # n, Number of messages in this conversation
	unread: Int # u
	share: [ShareNotification] # shr
	replyType: String #rt
}

type MsgWithGroupInfo implements MailItem {
	id: ID
	i4uid: Int
	cif: String
	origid: String
	entityId: ID # idnt
	forAcct: String
	autoSendTime: Float
	size: Float # s
	date: Float # d
	folderId: ID # l
	subject: String # su
	emailAddresses: [EmailAddress]
	excerpt: String # fr
	conversationId: ID # cid
	flags: String # f
	tags: String # t
	tagNames: String # tn
	revision: Int # rev
	changeDate: Float # md
	modifiedSequence: Int # ms
	invitations: [InviteInfo] # inv
	sortField: String # sf, Sort field used for cursor-based pagination
	share: [ShareNotification] # shr
	replyType: String #rt
}


enum InviteType {
	appt # Appointment
	task
}

type InviteInfo {
	type: InviteType #though type is a required value on the response, outdated invites come back as empty InviteInfo objects
	components: [InviteComponent] #comp
	replies: [InviteReplies] #replies
 }

type AddRecurrenceInfo { # <add>
	add: [AddRecurrenceInfo]
	exclude: [ExcludeRecurrenceInfo]
	except: [ExceptionRuleInfo]
	cancel: [CancelRuleInfo]
	# dates: SingleDates # TODO
	rule: [SimpleRepeatingRule]
}

type ExcludeRecurrenceInfo { # <exclude>
	exclude: [ExcludeRecurrenceInfo]
	except: [ExceptionRuleInfo]
}

type ExceptionRuleInfo { # <except>
	rangeType: Int
	recurId: String
	tz: String
	ridZ: String
	add: [AddRecurrenceInfo]
	exclude: [ExcludeRecurrenceInfo]
}

type CancelRuleInfo { # <cancel>
	rangeType: Int
	recurId: String
	tz: String
	ridZ: String
}

# type SingleDates { # <dates>
# }

type WkDay { # <wkday>
	day: Weekday
	ordwk: Int
}

type ByDayRule { # <byday>
	wkday: [WkDay]
}

type IntervalRule { # <interval>
	intervalCount: Int # ival
}

type SimpleRepeatingRule { # <rule>
	frequency: CalendarItemRecurrenceFrequency # freq
	interval: [IntervalRule]
	byday: [ByDayRule]
}

type RecurrenceInfo { # <recur>
	add: [AddRecurrenceInfo]
	exclude: [ExcludeRecurrenceInfo]
	except: [ExceptionRuleInfo]
	cancel: [CancelRuleInfo]
	# dates: [SingleDates] # TODO
	rule: [SimpleRepeatingRule]
}

type InviteReplies {
	reply: [CalendarItemReply]
}

type InviteComponent {
	# duration: DurationInfo # dur - TODO
	alarms: [CalendarItemAlarm]
	recurrence: [RecurrenceInfo] # recur
	allDay: Boolean
	attendees: [CalendarItemAttendee]
	calendarItemId: ID
	ciFolder: ID
	class: CalendarItemClass
	completedDateTime: String # completed , yyyyMMddThhmmssZ
	componentNum: Int # compNum
	date: Float # d
	description: [StringContent] # desc
	draft: Boolean
	end: [DtTimeInfo] # e
	excerpt: String # fr
	freeBusy: FreeBusyStatus # fb
	freeBusyActual: FreeBusyStatus # fba
	htmlDescription: [StringContent] # descHtml
	isException: Boolean # ex
	isOrganizer: Boolean # isOrg
	location: String # loc
	name: String
	noBlob: Boolean
	organizer: CalOrganizer # or
	percentComplete: String
	priority: String
	utcRecurrenceId: String #ridZ
	rsvp: Boolean
	sequence: Int # seq
	start: [DtTimeInfo] # s
	status: InviteCompletionStatus
	uid: String
	x_uid: String
	aid: String
}

type DtTimeInfo {
	date: String # d , of format YYYYMMDD['T'HHMMSS[Z]]
	timezone: String # tz
	utc: Float # u
}

type Invitation { # <inv>
	type: String!
	sequenceNumber: Int! # seq
	id: Int!
	componentNum: Int! # compNum
	recurrenceId: String # recurId
	tz: CalTZInfo
	components: [InviteComponent]! # comp
	replies: [InviteReplies]! # replies
	mimeParts: MimePart
}

type CalTZInfo { # <tz>
	id: String
	timezoneStdOffset: Int # stdoff
	timezoneDaylightOffset: Int # dayoff
	stdname: String
	dayname: String
	standard: TzOnsetInfo
	daylight: TzOnsetInfo
}

type TzOnsetInfo { # <standard>, <daylight>
	week: Int
	wkday: Int
	mon: Int
	mday: Int
	hour: Int
	min: Int
	sec: Int
}

type CalendarItemHitInfo { # <appt>; aka AppointmentHitInfo
	alarm: Boolean
	allDay: Boolean
	changeDate: Float # md
	class: CalendarItemClass!
	componentNum: Int # compNum
	date: Float # d
	timezoneOffset: Int
	duration: Float # dur
	excerpt: String # fr
	flags: String # f
	folderId: ID! # l
	freeBusy: FreeBusyStatus # fb
	freeBusyActual: FreeBusyStatus # fba
	id: ID!
	instances: [Instance] # inst
	invitations: [Invitation] # inv
	inviteId: ID! #invId
	isOrganizer: Boolean # isOrg
	isRecurring: Boolean # recur
	location: String # loc
	modifiedSequence: Int # ms
	name: String
	organizer: CalOrganizer # or
	participationStatus: ParticipationStatus
	percentComplete: String
	priority: String
	revision: Int # rev
	utcRecurrenceId: String # ridZ
	size: Float # s
	sortField: String # sf
	status: InviteCompletionStatus
	tagNames: String # tn
	tags: String # t
	uid: String
	x_uid: String
	aid: String
}

type ExternalAccountTestResponse {
	success: Boolean!
	error: String
}

input ExternalAccount {
	id: ID!
	name: String!
	accountType: AccountType
	isEnabled: Int
	host: String!
	port: String!
	connectionType: ConnectionType
	username: String!
	password: String!
}


type FreeBusyInstance {
	start: Float
	end: Float
}

type FreeBusy {
	id: String!
	tentative: [FreeBusyInstance]
	busy: [FreeBusyInstance]
	unavailable: [FreeBusyInstance]
	nodata: [FreeBusyInstance]
	free: [FreeBusyInstance]
}

type WorkingHoursInstance {
	start: Float
	end: Float
}

type WorkingHours {
	id: String!
	tentative: [WorkingHoursInstance]
	busy: [WorkingHoursInstance]
	unavailable: [WorkingHoursInstance]
	nodata: [WorkingHoursInstance]
	free: [WorkingHoursInstance]
}

##### Filters ######

enum Importance {
	high
	normal
	low
}

enum FilterMatchCondition {
	allof
	anyof
}

type AddressCondition {
	header: String!
	part: String!
	stringComparison: String!
	caseSensitive: Boolean
	value: String!
	valueComparison: String
	countComparison: String
	index: Int
	negative: Boolean
}

type BasicCondition {
	index: Int
	negative: Boolean
}

type BodyCondition {
	caseSensitive: Boolean
	value: String
	index: Int
	negative: Boolean
}

type ConversationCondition {
	where: String
	index: Int
	negative: Boolean
}

type DateCondition {
	dateComparison: String
	date: Float # d
	index: Int
	negative: Boolean
}

type FlagCondition {
	flagName: String!
	index: Int
	negative: Boolean
}

type HeaderCheckCondition {
	header: String!
	index: Int
	negative: Boolean
}

type HeaderCondition {
	header: String
	stringComparison: String
	valueComparison: String
	countComparison: String
	value: String
	caseSensitive: Boolean
	index: Int
	negative: Boolean
}

type ImportanceCondition {
	importance: Importance! # imp
	index: Int
	negative: Boolean
}

type InviteCondition {
	methods: [String]
	index: Int
	negative: Boolean
}

type MimeHeaderCondition {
	header: String
	stringComparison: String
	value: String
	caseSensitive: Boolean
	index: Int
	negative: Boolean
}

type SizeCondition {
	numberComparison: String
	size: String # s
	index: Int
	negative: Boolean
}

type FilterCondition {
	allOrAny: FilterMatchCondition! # condition

	addressBook: [HeaderCheckCondition] # addressBookTest
	address: [AddressCondition] # addressTest
	attachment: [BasicCondition] # attachmentTest
	body: [BodyCondition] # bodyTest
	bulk: [BasicCondition] # bulkTest
	contactRanking: [HeaderCheckCondition] # contactRankingTest
	conversation: [ConversationCondition] # conversationTest
	date: [DateCondition] # dateTest
	facebook: [BasicCondition] # facebookTest
	flag: [FlagCondition] # flaggedTest
	headerExists: [HeaderCheckCondition] # headerExistsTest
	header: [HeaderCondition] # headerTest
	importance: [ImportanceCondition] # importanceTest
	invite: [InviteCondition] # inviteTest
	linkedin: [BasicCondition] # linkedinTest
	list: [BasicCondition] # listTest
	me: [HeaderCheckCondition] # meTest
	mimeHeader: [MimeHeaderCondition] # mimeHeaderTest
	size: [SizeCondition] # sizeTest
	twitter: [BasicCondition] # twitterTest
	communityRequests: [BasicCondition] # communityRequestsTest
	communityContent: [BasicCondition] # communityContentTest
	communityConnections: [BasicCondition] # communityConnectionsTest
}

type BasicAction {
	index: Int
}

type FileIntoAction {
	folderPath: String
	copy: Boolean
	index: Int
}

type FlagAction {
	flagName: String
	index: Int
}

type TagAction {
	tagName: String!
	index: Int
}

type RedirectAction {
	address: String # a
	copy: Boolean
	index: Int
}

type ReplyAction {
	index: Int
	content: [String]
}

type NotifyAction {
	address: String # a
	subject: String # su
	maxBodySize: Int
	origHeaders: String
	index: Int
	content: [String]
}

type FilterAction {
	keep: [BasicAction] # actionKeep
	discard: [BasicAction] # actionDiscard
	fileInto: [FileIntoAction] # actionFileInto
	flag: [FlagAction] # actionFlag
	tag: [TagAction] # actionTag
	redirect: [RedirectAction] # actionRedirect
	reply: [ReplyAction] # actionReply
	notify: [NotifyAction] # actionNotify
	stop: [BasicAction] # actionStop
}

type Filter {
	name: String!
	active: Boolean!

	actions: [FilterAction] # filterActions
	conditions: [FilterCondition] # filterTests
}

##### End Of Filters ######

type Folder {
	absFolderPath: String
	acl: ACL
	appointments(start: Float, end: Float, offset: Int, limit: Int): SearchResponse
	tasks(folderId: ID, offset: Int, limit: Int, sortBy: String): SearchResponse
	color: Int
	flags: String
	id: ID
	uuid: ID
	name: String
	nonFolderItemCount: Int # Number of non-subfolder items in folder
	nonFolderItemCountTotal: Float # Total size of all of non-subfolder items in folder
	linkedFolders: [Folder] # Folders this user has linked from other users nested in this Folder
	folders: [Folder] # Folders nested in this Folder
	search: [Folder] #smart folders
	owner: String
	revision: Int
	view: FolderView
	parentFolderId: ID
	unread: Int
	query: String
	permissions: String # It will be available on linked folders only
	ownerZimbraId: ID
	sharedItemId: ID
	url: String
}

type ACL {
	grant: [ACLGrant]
}

type ACLGrant {
	address: String
	permissions: String
	granteeType: GranteeType
	zimbraId: ID
	password: String
	key: String
}

type LicenseAttrs {
	name: String!
	_content: Boolean!
}

type License {
	status: LicenseStatus!
	attr: [LicenseAttrs]
}

type AccountInfo {
	id: ID!
	name: String
	publicURL: String
	rest: String
	profileImageId: Int
	soapURL: String
	version: String
	identities: Identities
	dataSources: DataSources!
	signatures: Signatures
	attrs: AccountInfoAttrs
	prefs: Preferences
	license: License
	zimlets: AccountZimlet
}

type AccountZimlet {
	zimlet: [AccountZimletInfo]
}

type AccountZimletInfo {
	zimletContext: [AccountZimletContext]
	zimlet: [AccountZimletDesc]
	zimletConfig: [AccountZimletConfigInfo]
}

type AccountZimletContext {
	baseUrl: String
	priority: Int
	presence: ZimletPresence
}

type AccountZimletDesc {
	name: String
	version: String
	description: String
	extension: String
	label: String
	zimbraXZimletCompatibleSemVer: String
}

type AccountZimletConfigInfo {
	name: String
	version: String
	description: String
	extension: String
	target: String
	label: String
}

type AccountInfoAttrs {
	displayName: String
	zimbraFeatureMailEnabled: Boolean
	zimbraFeatureCalendarEnabled: Boolean
	zimbraFeatureRelatedContactsEnabled: Boolean
	zimbraFeatureChangePasswordEnabled: Boolean
	zimbraFeatureResetPasswordEnabled: Boolean
	zimbraFeatureWebClientOfflineAccessEnabled: Boolean
	zimbraMailBlacklistMaxNumEntries: Int
}

type Identities {
	identity: [Identity]
}

type Identity {
	id: ID!
	name: String
	_attrs: IdentityAttrs
	defaultSignature: ID
}

type DataSource {
	id: ID!
	connectionType: String
	defaultSignature: ID
	emailAddress: String
	l: ID # TODO: Normalize to `folderId`
	forwardReplySignature: ID
	fromDisplay: String
	host: String
	importOnly: Boolean
	isEnabled: Boolean
	name: String
	pollingInterval: Float
	port: String
	replyToAddress: String
	replyToDisplay: String
	smtpPort: String
	useAddressForForwardReply: Boolean
	username: String
	failingSince: String
	lastError: StringContent
}

type Signatures {
	signature: [Signature]
}

type Signature {
	id: ID
	name: String
	content: [SignatureContent]
}

type SignatureContent {
	type: String
	_content: String
}

type StringContent {
	_content: String
}

type DataSources {
	imap: [DataSource]
	pop3: [DataSource]
	cal: [DataSource]
}

type IdentityAttrs {
	zimbraPrefIdentityId: ID!
	zimbraPrefDefaultSignatureId: ID
	zimbraPrefForwardReplySignatureId: ID
	zimbraPrefForwardReplyFormat: String
	zimbraPrefFromAddress: String
	zimbraPrefFromAddressType: String
	zimbraPrefFromDisplay: String
	zimbraPrefIdentityName: String
	zimbraPrefMailSignatureStyle: String
	zimbraPrefReplyToAddress: String
	zimbraPrefReplyToDisplay: String
	zimbraPrefReplyToEnabled: Boolean
	zimbraPrefSaveToSent: Boolean
	zimbraPrefSentMailFolder: String
}

type Preferences {
	zimbraPrefAutoAddAppointmentsToCalendar: Boolean
	zimbraPrefCalendarAutoAddInvites: Boolean
	zimbraPrefCalendarFirstDayOfWeek: Int
	zimbraPrefCalendarInitialView: PrefCalendarInitialView
	zimbraPrefCalendarReminderEmail: String
	zimbraPrefCalendarWorkingHours: String
	zimbraPrefDefaultCalendarId: Int
	zimbraPrefDeleteInviteOnReply: Boolean
	zimbraPrefDisplayExternalImages: Boolean
	zimbraPrefGroupMailBy: String
	zimbraPrefMailPollingInterval: String
	zimbraPrefMailRequestReadReceipts: Boolean
	zimbraPrefMailSelectAfterDelete: PrefMailSelectAfterDelete
	zimbraPrefMailSendReadReceipts: PrefMailSendReadReceipts
	zimbraPrefMailTrustedSenderList: [String]
	zimbraPrefMarkMsgRead: Int
	zimbraPrefOutOfOfficeFromDate: String
	zimbraPrefOutOfOfficeReply: String
	zimbraPrefOutOfOfficeReplyEnabled: Boolean
	zimbraPrefOutOfOfficeStatusAlertOnLogin: Boolean
	zimbraPrefOutOfOfficeUntilDate: String
	zimbraPrefReadingPaneEnabled: Boolean
	zimbraPrefReadingPaneLocation: ReadingPaneLocation
	zimbraPrefPasswordRecoveryAddress: String
	zimbraPrefPasswordRecoveryAddressStatus: PasswordRecoveryAddressStatus
	zimbraPrefShowFragments: Boolean
	zimbraPrefWebClientOfflineBrowserKey: String
	zimbraPrefTimeZoneId: String
}

type NameId {
	id: ID
	name: String
}

type SignatureResponse {
	signature: [NameId]
}

type SearchResponse {
	contacts: [Contact]
	messages: [MessageInfo]
	conversations: [Conversation]
	tasks: [CalendarItemHitInfo]
	appointments: [CalendarItemHitInfo]
	more: Boolean
	offset: Int
	sortBy: String
	paginationSupported: Boolean
}

type SendMessageResponse {
	message: [MsgWithGroupInfo]
}

type SaveDraftResponse {
	message: [MessageInfo]
}

type Contact {
	id: ID!
	date: Float
	folderId: ID
	revision: Int
	sortField: String
	fileAsStr: String
	memberOf: String
	attributes: ContactAttributes
	members: [ContactListMember]
}

type ContactAttributes {
	firstName: String
	middleName: String
	lastName: String
	fullName: String
	email: String
	email2: String
	workEmail: String
	workEmail2: String
	homeEmail: String
	homeEmail2: String
	phone: String
	phone2: String
	mobile: String
	mobile2: String
	homePhone: String
	homePhone2: String
	workPhone: String
	workPhone2: String
	pager: String
	pager2: String
	fax: String
	fax2: String
	im: String
	im2: String
	im3: String
	im4: String
	nickname: String
	homeStreet: String
	homeCity: String
	homeState: String
	homePostal: String
	homeCountry: String
	workStreet: String
	workCity: String
	workState: String
	workPostal: String
	workCountry: String
	jobTitle: String
	company: String
	birthday: String
	anniversary: String
	website: String
	notes: String
	image: ContactImage
	userCertificate: String
	zimbraCalResType: String

	# Used for contact lists
	fileAs: String
	type: String
}

type ContactImage{
	ct: String
	filename: String
	part: String
	s: String
}

type ContactListMember {
	contacts: [Contact]
	type: String!
	value: ID!
}

input ContactAttrsInput {
	firstName: String
	middleName: String
	lastName: String
	fullName: String
	email: String
	email2: String
	workEmail: String
	workEmail2: String
	homeEmail: String
	homeEmail2: String
	phone: String
	phone2: String
	mobile: String
	mobile2: String
	homePhone: String
	homePhone2: String
	workPhone: String
	workPhone2: String
	pager: String
	pager2: String
	fax: String
	fax2: String
	im: String
	im2: String
	im3: String
	im4: String
	nickname: String
	homeStreet: String
	homeCity: String
	homeState: String
	homePostal: String
	homeCountry: String
	workStreet: String
	workCity: String
	workState: String
	workPostal: String
	workCountry: String
	jobTitle: String
	company: String
	birthday: String
	anniversary: String
	website: String
	notes: String
	image: String
	userCertificate: String

	# Used for contact lists
	fileAs: String
	type: String
}

input CreateContactInput {
	folderId: ID
	tagNames: String
	attributes: ContactAttrsInput!
}

input ContactListOps {
	op: String!
	type: String!
	value: String!
}

input ModifyContactInput {
	id: ID!
	folderId: ID
	tagNames: String
	attributes: ContactAttrsInput!
	memberOps: [ContactListOps]
}

type RelatedContact {
	email: String
	scope: Int
	p: String
}

type ContactFrequencyResponse {
	data: [ContactFrequencyData]
}

type ContactFrequencyData {
	by: String
	dataPoint: [ContactFrequencyDataPoints]
}

type ContactFrequencyDataPoints {
	label: Float
	value: Int
}

input EmailAddressInput {
	email: String!
	name: String!
	shortName: String!
}

type ShareInfo {
	folderId: ID!
	folderPath: String
	folderUuid: String
	granteeName: String
	granteeDisplayName: String
	granteeId: String
	granteeType: String
	ownerEmail: String
	ownerId: String
	ownerName: String
	rights: String
	view: FolderView
	mid: ID
}

type MailboxMetadata {
	meta: [MailboxMetadataMeta]
}

type MailboxMetadataMeta {
	section: String!
	_attrs: MailboxMetadataAttrs!
}

type MailboxMetadataAttrs {
	zimbraPrefCustomFolderTreeOpen: Boolean
	zimbraPrefFoldersExpanded: String
	zimbraPrefFolderTreeSash: Int
	zimbraPrefGenerateLinkPreviews: Boolean
	zimbraPrefGroupByList: String
	zimbraPrefMessageListDensity: String
	zimbraPrefMultitasking: String
	zimbraPrefReadingPaneSashHorizontal: Int
	zimbraPrefReadingPaneSashVertical: Int
	zimbraPrefSmartFolderTreeOpen: Boolean
	zimbraPrefUndoSendEnabled: Boolean
	zimbraPrefUndoSendTimeout: Int
	archivedFolder: String
	zimbraPrefSMIMEDefaultSetting: String
	zimbraPrefSMIMELastOperation: String
	zimbraPrefContactSourceFolderID: String
}

input MailboxMetadataSectionAttrsInput {
	zimbraPrefCustomFolderTreeOpen: Boolean
	zimbraPrefFoldersExpanded: String
	zimbraPrefFolderTreeSash: Int
	zimbraPrefGenerateLinkPreviews: Boolean
	zimbraPrefGroupByList: String
	zimbraPrefMessageListDensity: String
	zimbraPrefMultitasking: String
	zimbraPrefReadingPaneSashHorizontal: Int
	zimbraPrefReadingPaneSashVertical: Int
	zimbraPrefSmartFolderTreeOpen: Boolean
	zimbraPrefUndoSendEnabled: Boolean
	zimbraPrefUndoSendTimeout: Int
	archivedFolder: String
	zimbraPrefSMIMEDefaultSetting: String
	zimbraPrefSMIMELastOperation: String
	zimbraPrefContactSourceFolderID: String
}

type MimePart {
	body: Boolean
	filename: String
	part: ID # Mime part name
	content: String
	contentId: String
	contentType: String
	contentDisposition: String
	size: Float # Size in bytes
	mimeParts: [MimePart]
	url: String
	messageId: ID
}

input MimePartInput {
	body: Boolean
	filename: String
	part: ID # Mime part name
	content: String
	contentId: String
	contentType: String
	contentDisposition: String
	size: Float # Size in bytes
	mimeParts: [MimePartInput]
	url: String
	messageId: ID
	attachments: [AttachmentInput]
}

input ExistingAttachmentInput {
	messageId: ID
	part: ID
}

input AttachmentInput {
	attachmentId: String
	existingAttachments: [ExistingAttachmentInput]
}

type AutoCompleteResponse {
	canBeCached: Boolean
	match: [AutoCompleteMatch]
}

type AutoCompleteGALResponse {
	contacts: [Contact]
}

type AutoCompleteMatch {
	email: String
	type: AutoCompleteMatchType
	ranking: Int
	isGroup: Boolean
	exp: Boolean
	id: ID
	folderId: ID
	display: String
	first: String
	middle: String
	last: String
	full: String
	nick: String
	company: String
	fileas: String
}

input CalendarItemInput {
	id: ID
	modifiedSequence: Float
	revision: Float
	componentNum: Int # comp
	message: CalendarItemMessageInput!
}

input CalendarItemMessageInput {
	folderId: ID #l
	subject: String #su
	invitations: CalendarItemInviteInput #inv
	mimeParts: [MimePartInput] #mp
	emailAddresses: [MailItemEmailAddressInput] #e
	attachments: [AttachmentInput] #attach
	replyType: InviteReplyType #rt
}

input SendMessageInput {
	id: ID #id
	origId: ID #origid
	attach: [AttachmentInput]
	attachmentId: ID #aid
	replyType: String #rt
	inReplyTo: String #irt
	flags: String #f
	autoSendTime: Float #autoSendTime
	draftId: ID #did
	entityId: String #idnt
	subject: String #su
	mimeParts: [MimePartInput] #mp
	emailAddresses: [MailItemEmailAddressInput] #e
	attachments: [AttachmentInput] #attach
}

input CalendarItemInviteInput {
	components: [CalendarItemInviteComponentInput]!
}

input MailItemEmailAddressInput {
	address: String!
	name: String
	type: AddressType!
}

input CalendarItemInviteComponentInput {
	name: String!
	location: String
	start: CalendarItemDateTimeInput
	end: CalendarItemDateTimeInput
	exceptId: CalendarOptionalItemDateTimeInput
	freeBusy: FreeBusyStatus
	allDay: Boolean
	organizer: CalendarItemOrganizerInput
	recurrence: CalendarItemRecurrenceInput
	attendees: [CalendarItemAttendeesInput]
	alarms: [CalendarItemAlarmInput]
	class: CalendarItemClass!
	priority: String
	percentComplete: String
	status: InviteCompletionStatus
	noBlob: Boolean
	description: [CalendarItemInviteComponentDescriptionInput]
}

input CalendarItemInviteComponentDescriptionInput {
	_content: String
}

input CalendarItemDateTimeInput {
	timezone: String
	date: String!
}

input CalendarOptionalItemDateTimeInput {
	timezone: String
	date: String
}

type CalendarItemAttendee {
	role: ParticipationRole
	participationStatus: ParticipationStatus
	rsvp: Boolean
	address: String
	name: String
	calendarUserType: String
}

type CalendarItemReply {
	participationStatus: ParticipationStatus
	attendee: String
}

input CalendarItemAttendeesInput {
	role: ParticipationRole
	participationStatus: ParticipationStatus
	rsvp: Boolean
	address: String!
	name: String,
	calendarUserType: String
}

type CalendarItemAlarmTriggerRelative {
	weeks: Int
	days: Int
	hours: Int
	minutes: Int
	seconds: Int
	relatedTo: AlarmRelatedTo
	negative: Boolean!
}

type CalendarItemAlarmAttendees {
	email: String!
}

type CalendarItemAlarmTrigger {
	relative: [CalendarItemAlarmTriggerRelative]
}

type CalendarItemAlarm {
	action: AlarmAction!
	trigger: [CalendarItemAlarmTrigger]
}

type RecoverAccount {
	recoveryAccount: String
	recoveryAttemptsLeft: Int
}

type WhiteBlackAddress {
	_content: String!
	op: String
}

type WhiteBlackListArr {
	addr: [WhiteBlackAddress]
}

type WhiteBlackList {
	whiteList: [WhiteBlackListArr]!
	blackList: [WhiteBlackListArr]!
}

input CalendarItemAlarmInput {
	action: AlarmAction!
	trigger: CalendarItemAlarmTriggerInput!
	attendees: CalendarItemAlarmAttendeesInput
}

input CalendarItemAlarmAttendeesInput {
	email: String!
}

input CalendarItemAlarmTriggerInput {
	relative: CalendarItemAlarmTriggerRelativeInput
	absolute: CalendarItemAlarmTriggerAbsoluteInput
}

input CalendarItemAlarmTriggerRelativeInput {
	weeks: Int
	days: Int
	hours: Int
	minutes: Int
	seconds: Int
	relatedTo: AlarmRelatedTo
	negative: Boolean
}

input CalendarItemAlarmTriggerAbsoluteInput {
	date: String!
}

input CalendarItemOrganizerInput {
	address: String
	name: String
	sentBy: String
}

input CalendarItemRecurrenceInput {
	add: CalendarItemRecurrenceAddInput
}

input CalendarItemRecurrenceAddInput {
	rule: CalendarItemRecurrenceRuleInput
}

input CalendarItemRecurrenceRuleInput {
	interval: CalendarItemRecurrenceIntervalInput
	frequency: CalendarItemRecurrenceFrequency
}

input CalendarItemRecurrenceIntervalInput {
	intervalCount: Int!
	zimbraPrefAutoAddAppointmentsToCalendar: Boolean
}

input NewMountpointSpec {
	name: String!
	owner: String
	view: SearchType
	flags: String
	ownerZimbraId: ID # zid
	sharedItemId: ID # rid
	color: Int
	reminder: Boolean
	parentFolderId: ID
}

input CreateMountpointInput {
	link: NewMountpointSpec
}

input FolderQueryInput {
	uuid: ID
	id: ID
	view: FolderView
}

input FolderActionInput {
	id: ID!
	op: String!
	grant: [GrantInput]
	name: String
	folderId: ID
	zimbraId: ID
}

# Special case of FolderAction for `changeFolderColor` resolver
input FolderActionChangeColorInput {
	id: ID!
	color: Int!
}

# Special case of FolderAction for `checkCalendar` resolver
input FolderActionCheckCalendarInput {
	id: ID!
	value: Boolean
}

input ContactFrequencySpec {
	range: String!
	interval: String!
}

input GrantInput {
	address: String
	granteeType: GranteeType!
	key: String
	password: String
	permissions: String!
	zimbraId: ID
}

input InviteReplyInput {
	componentNum: Int! #compNum
	id: ID!
	verb: InviteReplyVerb!
	updateOrganizer: Boolean
	message: CalendarItemMessageInput
	exceptId: InstanceDate
}

input PreferencesInput {
	zimbraPrefAutoAddAppointmentsToCalendar: Boolean
	zimbraPrefCalendarAutoAddInvites: Boolean
	zimbraPrefDefaultCalendarId: Int
	zimbraPrefCalendarFirstDayOfWeek: Int
	zimbraPrefCalendarInitialView: PrefCalendarInitialView
	zimbraPrefCalendarReminderEmail: String
	zimbraPrefCalendarWorkingHours: String
	zimbraPrefDisplayExternalImages: Boolean
	zimbraPrefGroupMailBy: String
	zimbraPrefMailPollingInterval: String
	zimbraPrefMailRequestReadReceipts: Boolean
	zimbraPrefMailSelectAfterDelete: PrefMailSelectAfterDelete
	zimbraPrefMailSendReadReceipts: PrefMailSendReadReceipts
	zimbraPrefMailTrustedSenderList: [String]
	zimbraPrefMarkMsgRead: Int
	zimbraPrefOutOfOfficeFromDate: String
	zimbraPrefOutOfOfficeReply: String
	zimbraPrefOutOfOfficeReplyEnabled: Boolean
	zimbraPrefOutOfOfficeStatusAlertOnLogin: Boolean
	zimbraPrefOutOfOfficeUntilDate: String
	zimbraPrefReadingPaneEnabled: Boolean
	zimbraPrefReadingPaneLocation: ReadingPaneLocation
	zimbraPrefShowFragments: Boolean
	zimbraPrefWebClientOfflineBrowserKey: String
	zimbraPrefTimeZoneId: String
}

input ModifyIdentityInput {
	id: ID!
	attrs: IdentityAttrsInput
}

input ZimletPreferenceInput {
	name: String!
	presence: String!
}

##### FilterInput #####

input AddressConditionInput {
	header: String!
	part: String!
	stringComparison: String!
	caseSensitive: Boolean
	value: String!
	valueComparison: String
	countComparison: String
	index: Int
	negative: Boolean
}

input BasicConditionInput {
	index: Int
	negative: Boolean
}

input BodyConditionInput {
	caseSensitive: Boolean
	value: String
	index: Int
	negative: Boolean
}

input ConversationConditionInput {
	where: String
	index: Int
	negative: Boolean
}

input DateConditionInput {
	dateComparison: String
	date: Float # d
	index: Int
	negative: Boolean
}

input FlagConditionInput {
	flagName: String!
	index: Int
	negative: Boolean
}

input HeaderCheckConditionInput {
	header: String!
	index: Int
	negative: Boolean
}

input HeaderConditionInput {
	header: String
	stringComparison: String
	valueComparison: String
	countComparison: String
	value: String
	caseSensitive: Boolean
	index: Int
	negative: Boolean
}

input ImportanceConditionInput {
	importance: Importance! # imp
	index: Int
	negative: Boolean
}

input InviteConditionInput {
	methods: [String]
	index: Int
	negative: Boolean
}

input MimeHeaderConditionInput {
	header: String
	stringComparison: String
	value: String
	caseSensitive: Boolean
	index: Int
	negative: Boolean
}

input SizeConditionInput {
	numberComparison: String
	size: String # s
	index: Int
	negative: Boolean
}

input FilterConditionInput {
	allOrAny: FilterMatchCondition! # condition

	addressBook: [HeaderCheckConditionInput] # addressBookTest
	address: [AddressConditionInput] # addressTest
	attachment: [BasicConditionInput] # attachmentTest
	body: [BodyConditionInput] # bodyTest
	bulk: [BasicConditionInput] # bulkTest
	contactRanking: [HeaderCheckConditionInput] # contactRankingTest
	conversation: [ConversationConditionInput] # conversationTest
	date: [DateConditionInput] # dateTest
	facebook: [BasicConditionInput] # facebookTest
	flag: [FlagConditionInput] # flaggedTest
	headerExists: [HeaderCheckConditionInput] # headerExistsTest
	header: [HeaderConditionInput] # headerTest
	importance: [ImportanceConditionInput] # importanceTest
	invite: [InviteConditionInput] # inviteTest
	linkedin: [BasicConditionInput] # linkedinTest
	list: [BasicConditionInput] # listTest
	me: [HeaderCheckConditionInput] # meTest
	mimeHeader: [MimeHeaderConditionInput] # mimeHeaderTest
	size: [SizeConditionInput] # sizeTest
	twitter: [BasicConditionInput] # twitterTest
	communityRequests: [BasicConditionInput] # communityRequestsTest
	communityContent: [BasicConditionInput] # communityContentTest
	communityConnections: [BasicConditionInput] # communityConnectionsTest
}

input BasicActionInput {
	index: Int
}

input FileIntoActionInput {
	folderPath: String
	copy: Boolean
	index: Int
}

input FlagActionInput {
	flagName: String
	index: Int
}

input TagActionInput {
	tagName: String!
	index: Int
}

input RedirectActionInput {
	address: String # a
	copy: Boolean
	index: Int
}

input ReplyActionInput {
	index: Int
	content: [String]
}

input NotifyActionInput {
	address: String # a
	subject: String # su
	maxBodySize: Int
	origHeaders: String
	index: Int
	content: [String]
}

input FilterActionInput {
	keep: [BasicActionInput] # actionKeep
	discard: [BasicActionInput] # actionDiscard
	fileInto: [FileIntoActionInput] # actionFileInto
	flag: [FlagActionInput] # actionFlag
	tag: [TagActionInput] # actionTag
	redirect: [RedirectActionInput] # actionRedirect
	reply: [ReplyActionInput] # actionReply
	notify: [NotifyActionInput] # actionNotify
	stop: [BasicActionInput] # actionStop
}

input FilterInput {
	name: String!
	active: Boolean!

	actions: [FilterActionInput] # filterActions
	conditions: [FilterConditionInput] # filterTests
}

##### End Of FilterInput #####

input ShareNotificationInput {
	item: ShareNotificationItemInput!
	address: ShareNotificaitonEmailAddressInput!
	notes: String
}

input ShareNotificationItemInput {
	id: ID!
}

input ShareNotificaitonEmailAddressInput {
	address: String!
	type: AddressType
	personalName: String
}

input IdentityAttrsInput {
	zimbraPrefIdentityId: ID
	zimbraPrefDefaultSignatureId: ID
	zimbraPrefForwardReplySignatureId: ID
	zimbraPrefForwardReplyFormat: String
	zimbraPrefFromAddress: String
	zimbraPrefFromAddressType: String
	zimbraPrefFromDisplay: String
	zimbraPrefIdentityName: String
	zimbraPrefMailSignatureStyle: String
	zimbraPrefReplyToAddress: String
	zimbraPrefReplyToDisplay: String
	zimbraPrefReplyToEnabled: Boolean
	zimbraPrefSaveToSent: Boolean
	zimbraPrefSentMailFolder: String
}

input ExternalAccountAddInput {
	accountType: AccountType
	connectionType: ConnectionType
	emailAddress: String
	host: String!
	isEnabled: Boolean
	l: ID! # TODO: Normalize to `folderId`
	leaveOnServer: Boolean
	name: String!
	password: String!
	port: String!
	username: String!
}

input ExternalAccountTestInput {
	accountType: AccountType
	connectionType: ConnectionType
	emailAddress: String
	host: String!
	leaveOnServer: Boolean
	port: String!
	username: String!
	password: String!
}

input ExternalAccountModifyAttrsInput {
	id: ID
	accountType: AccountType
	defaultSignature: ID
	description: String
	emailAddress: String
	fromDisplay: String
	name: String
	replyToAddress: String
	replyToDisplay: String
	replyToEnabled: Boolean
	storeAndForward: String
	useAddressForForwardReply: Boolean
	username: String
	host: String
	signatureValue: String
	importOnly: Boolean
	forwardReplySignature: ID
	connectionType: ConnectionType
	isEnabled: Boolean
	port: String
	smtpPort: String
}

input ExternalAccountImportInput {
	accountType: AccountType
	id: ID!
}

# Include one of these fields to query for a folder
input GetFolderFolderInput {
	uuid: ID
	parentFolderId: ID # Folder ID
	path: String # Fully qualifed folder path
}

input Cursor {
	id: ID
	sortVal: String
	endSortVal: String
	includeOffset: Boolean
}

input MailItemHeaderInput {
	n: String!
}

input NameIdInput {
	id: ID
	name: String
}
input InstanceDate {
	date: String
}
input DeleteAppointmentInput {
	instanceDate: InstanceDate
	inviteId: String!
	componentNum: String!
	start: Int,
	message: CalendarItemMessageInput
}
input SignatureInput {
	id: ID
	name: String
	content: SignatureContentInput
	contentId: String
}

input SearchFolderInput {
	id: ID!
	query: String!
	types: FolderView!
}

input SignatureContentInput {
	type: String
	_content: String
}

input WhiteBlackAddressOpts {
	_content: String!
	op: String
}

input WhiteBlackListArrInput {
	addr: [WhiteBlackAddressOpts]
}

input WhiteBlackListInput {
	whiteList: WhiteBlackListArrInput
	blackList: WhiteBlackListArrInput
}

input SnoozeInput {
	id: ID!
	until: Float!
}

input DismissInput {
	id: ID!
	dismissedAt: Float!
}

input StringContentInput {
	_content: String
}

input AddMsgInput {
	folderId: ID!
	content: StringContentInput
}

input Grantee {
	id: ID
	type: String
	name: String
}

input Owner {
	by: String
	_content: String
}

##### SMIME Certificates type #####

type SMimePublicCert {
	store: String!
	field: String!
	_content: String
}

type SMimePublicCerts {
	email: String
	cert: [SMimePublicCert]
}

type SMimePublicCertsResponse{
	certs: [SMimePublicCerts]
}

type SMimeMessage {
	id: ID
	content: String
}

##### End Of SMIME Certificates type #####

type ActionOpResponseData {
	id: ID!
	op: String!
}

type ActionOpResponse {
	action: ActionOpResponseData
}

# Zimbra GraphQL Queries
# - [[SOAP API Reference]](https://files.zimbra.com/docs/soap_api/8.7.11/api-reference/index.html)
# - [[SOAP Documentation]](https://github.com/Zimbra/zm-mailbox/blob/develop/store/docs/soap.txt)
# - [[SOAP XML-to-JSON Documentation]](https://wiki.zimbra.com/wiki/Json_format_to_represent_soap)
type Query {
	accountInfo: AccountInfo
	autoComplete(
		name: String
		type: GalSearchType,
		needExp: Boolean,
		folders: String,
		includeGal: Boolean
	): AutoCompleteResponse
	autoCompleteGAL(
		limit: Int
		name: String!
		type: GalSearchType
		needExp: Boolean
	): AutoCompleteGALResponse
	downloadMessage(id: ID!, isSecure: Boolean): SMimeMessage
	freeBusy(names: [String!], start: Float, end: Float): [FreeBusy]
	getContact(
		id: ID,
		ids: [ID!],
		derefGroupMember: Boolean
		memberOf: Boolean
	): [Contact]
	getAppointments(
		calExpandInstStart: Float!,
		calExpandInstEnd: Float!,
		query: String!,
		limit: Int!,
		offset: Int!,
		types: SearchType
	): SearchResponse
	getContactFrequency(
		email: String!
		by: String!
		offsetInMinutes: String
		spec: [ContactFrequencySpec!]
	): ContactFrequencyResponse
	getConversation(
		id: ID!,
		header: [MailItemHeaderInput],
		html: Boolean,
		max: Int,
		needExp: Boolean,
		fetch: String
	): Conversation
	getFilterRules: [Filter]
	getFolder(
		visible: Boolean,
		needGranteeName: Boolean,
		view: FolderView,
		depth: Int,
		traverseMountpoints: Boolean
		folder: GetFolderFolderInput
	): Folder
	getMailboxMetadata(section: String): MailboxMetadata
	getMessage(
		id: ID!,
		header: [MailItemHeaderInput],
		html: Boolean,
		max: Int,
		needExp: Boolean,
		neuter: Boolean,
		part: ID,
		raw: Boolean,
		read: Boolean,
		ridZ: String
	): MessageInfo
	getSMimePublicCerts(contactAddr: String!, store: String!): SMimePublicCertsResponse
	getSearchFolder: Folder
	getWhiteBlackList: WhiteBlackList
	getWorkingHours(names: [String!], start: Float, end: Float): [WorkingHours]
	noop: Boolean
	preferences: Preferences
	recoverAccount(
		op: RecoverAccountOp!
		email: String!
		channel: SetRecoveryAccountChannel!
	): RecoverAccount
	relatedContacts(email: String!): [RelatedContact]
	shareInfo(
		internal: Boolean,
		includeSelf: Boolean,
		grantee: Grantee,
		owner: Owner
	): [ShareInfo]
	# Perform a search for a variety types using a flexible query interface.
	# [[SOAP Search API Documentation]](https://files.zimbra.com/docs/soap_api/8.7.11/api-reference/zimbraMail/Search.html)
	# [[Query Tips]](https://wiki.zimbra.com/wiki/Zimbra_Web_Client_Search_Tips)
	search(
		contact: String
		cursor: Cursor,
		fetch: String,
		fullConversation: Boolean,
		limit: Int,
		needExp: Boolean,
		memberOf: Boolean,
		offset: Int,
		query: String,
		recip: Int,
		sortBy: SortBy,
		types: SearchType
	): SearchResponse

	searchGal(
		needIsOwner: Boolean,
		needIsMember: NeedIsMemberType,
		type: GalSearchType,
		name: String,
		offset: Int,
		limit: Int,
		locale: String,
		sortBy: String,
		needExp: Boolean
	): SearchResponse

	taskFolders: [Folder]

	# Below queries should not be present here as it is used by apollo-link-state for local data management
	# but eslint-plugin-graphql is not able to handle those scenarios as mentioned in https://github.com/apollographql/eslint-plugin-graphql/issues/99
	localFolderEmail(id: String!): MessageInfo
	localFolderEmails(folderName: String!): [MessageInfo]
}

type Mutation {
	action(
		type: ActionTypeName!,
		id: ID,
		ids: [ID!],
		op: String!,
		color: Int,
		constraints: String,
		flags: String,
		folderId: ID,
		rgb: String,
		tagNames: String,
		name: String
	): Boolean
	testExternalAccount(externalAccount: ExternalAccountTestInput!): ExternalAccountTestResponse
	addExternalAccount(externalAccount: ExternalAccountAddInput!): ID
	addMessage(message: AddMsgInput!): MessageInfo
	cancelTask(inviteId: ID!): Boolean
	changeFolderColor(id: ID!, color: Int!): Boolean
	changePassword(
		loginNewPassword: String!
		password: String!
		username: String!
	): AuthResponse
	modifyProfileImage(uid: String!): String
	checkCalendar(id: ID!, value: Boolean!): Boolean
	contactAction(
		id: ID
		ids: [ID!]
		folderId: ID
		op: String!
	): ActionOpResponse
	conversationAction(
		ids: [ID!]!
		op: String!
	): Boolean
	createAppointment(accountName: String, appointment: CalendarItemInput!): Boolean
	createAppointmentException(accountName: String, appointment: CalendarItemInput!): Boolean
	createCalendar(name: String!, color: Int!, url: String): Folder
	createContact(contact: CreateContactInput!): Contact
	createContactList(contact: CreateContactInput!): Contact
	modifyContact(contact: ModifyContactInput!): Contact
	modifyContactList(contact: ModifyContactInput!): Contact
	createFolder(
		color: Int
		fetchIfExists: Boolean
		flags: String
		name: String!
		parentFolderId: ID
		url: String
		view: FolderView
	): Folder
	createMountpoint(
		link: NewMountpointSpec!
	): Boolean
	createSharedCalendar(link: NewMountpointSpec!): Boolean
	createSearchFolder(
		name: String!
		parentFolderId: ID
		query: String!
		types: FolderView
	): Folder
	createSignature(
		signature: SignatureInput!
	): SignatureResponse
	createTask(task: CalendarItemInput!): Boolean
	deleteAppointment(appointment: DeleteAppointmentInput!): Boolean
	deleteExternalAccount(id: ID!): Boolean
	deleteSignature(signature: NameIdInput!): String
	folderAction(action: FolderActionInput!): Boolean
	itemAction(id: ID, ids: [ID], folderId: ID, op: String!): Boolean
	importExternalAccount(externalAccount: ExternalAccountImportInput!): Boolean
	logout: Boolean
	login(
		username: String!,
		password: String,
		recoveryCode: String,
		tokenType: String,
		persistAuthTokenCookie: Boolean
	): AuthResponse
	messageAction(
		ids: [ID!]!
		op: String!
	): Boolean
	modifyExternalAccount(
		id: ID!
		type: AccountType
		attrs: ExternalAccountModifyAttrsInput!
	): Boolean
	modifyAppointment(accountName: String, appointment: CalendarItemInput!): ModifyAppointmentResponse
	modifyIdentity(id: ID!, attrs: IdentityAttrsInput!): Boolean
	modifyPrefs(prefs: PreferencesInput!): Boolean
	modifyZimletPrefs(zimlets: [ZimletPreferenceInput!]): ModifyZimletPrefsResponse
	modifyFilterRules(filters: [FilterInput!]): Boolean
	modifySignature(signature: SignatureInput!): String
	modifySearchFolder(search: SearchFolderInput!): Boolean
	modifyTask(task: CalendarItemInput!): Boolean
	modifyWhiteBlackList(whiteBlackList: WhiteBlackListInput!): Boolean
	moveTask(inviteId: ID!, destFolderId: ID!): String
	prefEnableOutOfOfficeAlertOnLogin(value: Boolean!): Boolean
	prefEnableOutOfOfficeReply(value: Boolean!): Boolean
	prefOutOfOfficeFromDate(value: String!): String
	prefOutOfOfficeReply(value: String!): String
	prefOutOfOfficeUntilDate(value: String!): String
	recoverAccount(
		op: RecoverAccountOp!
		email: String!
		channel: SetRecoveryAccountChannel!
	): RecoverAccount
	resetPassword(password: String!): Boolean
	saveDraft(message: SendMessageInput!): SaveDraftResponse
	sendMessage(message: SendMessageInput!): SendMessageResponse
	sendInviteReply(inviteReply: InviteReplyInput!): InviteReplyResponse
	sendShareNotification(shareNotification: ShareNotificationInput!): Boolean
	setMailboxMetadata(section: String, attrs: MailboxMetadataSectionAttrsInput!): Boolean
	snoozeCalendarItem(appointment: SnoozeInput, task: SnoozeInput): Boolean,
	dismissCalendarItem(appointment: DismissInput, task: DismissInput): Boolean,
	uploadMessage(value: String!): String
	setRecoveryAccount(
		channel: SetRecoveryAccountChannel!
		op: SetRecoveryAccountOp!
		recoveryAccount: String
		recoveryAccountVerificationCode: String
	): Boolean

	# Below mutations should not be present here as it is used by apollo-link-state for local data management
	# but eslint-plugin-graphql is not able to handle those scenarios as mentioned in https://github.com/apollographql/eslint-plugin-graphql/issues/99
	loadLocalFolderEmails(accountName: String, name: String, dataDirPath: String): [MessageInfo]
	saveLocalFolderEmails(accountName: String, name: String, dataDirPath: String, data: [String]): [MessageInfo]
	updateLocalFolderEmailAttachmentPath(id: String, accountName: String, folderPath: String, folderName: String): [MessageInfo]
}

schema {
	query: Query
	mutation: Mutation
}
